## 实现 vue2 的主要功能

- new Vue 发生了什么
- 模板编译
- 响应式系统
- 事件处理
- 插槽





## vue2 diff 算法

### 1. 流程

详情见代码 src/vdom/patch，对比核心代码发生在updateChildren





### 2.缺点

>  vue2 diff 算法对比的过程中，在经历完 头头、头尾、尾尾、尾头后，会根据旧节点做一个映射表，键为 key（v-for 提供的key），值为 索引。在旧节点中找到能复用的节点，从而移动旧节点。



1. 静态节点不缓存

   在vue2中，每次渲染都会重新生成虚拟DOM 树，即使是静态节点也会重新生成和比较，这导致了不必要的开销，尤其是在包含大量静态内容的应用中

   

2. 更新时全量比较

   vue2 的 diff 算法会对整个虚拟 DOM 树进行全量比较，虽然已经尽量优化了性能，但在某些复杂的场景下，仍然会导致性能问题。例如，嵌套层级较深的组件树或者包含大量子节点的组件更新时，可能会出现性能瓶颈。

> vue2的diff算法在对于大列表的数据更新效率不高，因为它需要对整个列表进行diff，即使只有少数几个元素发生变化。这是因为vue2的diff算法是基于索引的，它依赖于可以通过索引直接获取到相应的vnode，然后进行比较。但当列表较大时，索引的查找成本较高，这使得算法的时间复杂度随着列表的大小而线性增加
>
> 使用key之后，Vue可以更快地确定哪些元素可以复用。

```js
//这里是在创建旧节点的映射表 
oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);

//有key 通过key来找到索引，没有key则会遍历旧节点列表来找到对应的索引
//没有key的情况下，当列表较大时，索引查找成本较高
idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
```



3. 列表更新的效率问题

   在处理列表更新时，vue2 的 diff 算法通过 key 属性来优化节点的复用和移动。但是当key不正确或者未设置时，栓发的性能会大幅下降，导致不必要的DOM 操作。即使设置了key，在列表元素频繁增删的情况下，diff 算法的性能仍然不够理想。

> 长列表：
>
> ​	在非常长的列表中，即使使用 `key` 来优化节点的复用和移动，diff 算法仍然需要遍历整个列表，计算复杂度为 O(n)，在极端情况下（如同时进行大量插入、删除和移动操作），性能开销仍然较大。
>
> 频繁插入和删除操作：
>
> ​	如果列表频繁变动，特别是在头部或者中间插入、删除操作时，vue需要重新计算每个项的位置，如下面的例子。

```html
头部插入：
<ul>
  <li key="1">Item 1</li>
  <li key="2">Item 2</li>
  <li key="3">Item 3</li>
</ul>

<ul>
  <li key="4">Item 4</li>
  <li key="1">Item 1</li>
  <li key="2">Item 2</li>
  <li key="3">Item 3</li>
</ul>
```

1. 比较节点：

   1. Vue 将新的 `key="4"` 与旧的 `key="1"` 进行比较，发现它们不相同。
   2. Vue 需要插入一个新的节点并**重新调整后面的所有节点**。

2. 移动节点：

   1. 旧的 `key="1"` 需要移到新位置。
   2. 旧的 `key="2"` 需要移到新位置。
   3. 旧的 `key="3"` 需要移到新位置。

   ​	

```html
中间插入：
<ul>
  <li key="1">Item 1</li>
  <li key="5">Item 5</li>
  <li key="2">Item 2</li>
  <li key="3">Item 3</li>
</ul>
```

1. 比较节点：
   1. Vue 将新的 `key="1"` 与旧的 `key="1"` 进行比较，发现它们相同，继续比较下一个节点。
   2. Vue 将新的 `key="5"` 与旧的 `key="2"` 进行比较，发现它们不相同。
2. 插入新节点：
   1. Vue 需要插入新的 `key="5"` 节点。
3. 移动节点：
   1. 旧的 `key="2"` 和 `key="3"` 需要移到新位置。



所以在vue2的diff 算法过程中，在头部或中间插入或删除节点时，所有后续节点的位置都需要重新计算和更新。这种重新计算会导致多个 DOM 操作。每一次 DOM 操作都会触发浏览器的重新布局（reflow）和重绘（repaint），这些操作都是相对昂贵的。



> ​	在vue2 的diff 算法中，它会把新节点在旧节点中寻找，如果可以复用，那么就会产生移动。vue2的diff 算法没有去关注哪些节点不用去移动，这样就会产生额外的移动操作
>
> vue3中采用了最长递增子序列的思想，尽量减少移动节点，减少无意义的移动
>
> 例子：
>
> a b c d
>
> e b c d a h
>
> 对于 e 节点进行双端对比，发现匹配不到，会创建 e节点添加到头部，然后指针移动到b节点，继续双端对比，发现还是匹配不到，拿b节点去旧节点中找相同的b节点（通过key可以快速找到），然后将b节点移动到前面，指针继续后移动到c节点...
>
> 对于旧列表 bcd 节点，新列表中也是 bcd ，完全可以不用移动，只需要将 a节点移动到 d后面就可以



4. Vue 2 使用数据劫持（Object.defineProperty）实现双向数据绑定，虽然这在大多数情况下表现良好，但在处理大量数据或者频繁更新的场景下，仍然会有一定的性能开销。





## vue3 的 diff

### 1.相比于vue2有哪些改进

1. 静态节点提升

   在vue3中，编译器会在编译阶段分析模块，并将静态节点提升到渲染函数之外。这意味着静态节点只会被创建一次，而不是在每次渲染时重新创建，从而减少了渲染开销。

   

2. block和patch flag

   vue3 引入了块级优化（block optimization）和补丁标志（patch flag）的概念。块级优化通过将模板分成动态和静态部分，使得虚拟DOM的比较和更新更高效。补丁标志用于指示哪些部分发生了变化，从而避免不必要的比较操作

   

3. 更智能的diff算法（最长递增子序列）

   采用了双端比较和最长递增子序列（LIS），以更高效地处理节点的插入、删除和移动操作。

   双端比较（头头、尾尾）：同时从列表的两端进行比较，可以快速找到不匹配的节点，从而减少了比较的次数和DOM操作

   最长递增子序列算法：用于优化节点的移动操作，确保只进行必要的最小移动操作，减少了性能开销。

   



### 2. diff算法流程以及有哪些优化？

什么是最长递增子序列？

> 最长递增子序列是一个数组中按顺序排列的最大子序列，其元素按递增顺序排列。例如，数组 [10, 22, 9, 33, 21, 50, 41, 60, 80] 的 LIS 是 [10, 22, 33, 50, 60, 80]。



在 Vue 3 的 diff 算法中，LIS 用于确定在更新列表时哪些节点可以保留原位置，从而减少需要移动的节点数量。（vue2的diff 算法没有去关注哪些节点不用去移动）



vue3 diff 对比过程：

- 旧列表：[A, B, C, D]
- 新列表：[B, C, E, A]

1. 首先双端比较，从头和尾`同时`进行，快速找到不匹配的部分

   A 和 B ， D 和A 不匹配，此时停止双端对比，不匹配的中间部分为[B,C,E,A] 和 [A,B,C,D]

   > 如果：
   > 旧列表： [A,B,C,D,E]
   >
   > 新列表:  [A,C,D,B,E]
   >
   > 停止双端对比后，不匹配的部分为 B,C,D 和 C,D,B

2. 建立映射表

   建立旧列表中`剩余元素`的映射表（key为vnode，value为vnode所在的索引）

   ```js
   map: {
       A:0,
     	B:1,
     	C:2,
       D:3
   }
   ```

3. 生成新列表中每个元素在旧列表对应的索引

   ```js
   旧列表：[A,B,C,D]
   旧列表索引:{
       A:0,
     	B:1,
     	C:2,
       D:3
   }
   新列表：[B, C, E, A]
   新列表元素在旧列表中的索引:[1,2,undefiend,0]
   undefiend 代表是新增的元素，在旧列表中没有找到
   ```

4. 计算LIS（最长递增子序列）

   尽可能到找到最长递增的（通过贪心+二分查找来完成），这些节点可以不用移动。在索引数组 [1, 2, undefined, 0] 中计算 LIS。LIS 是 [1, 2]，对应的新列表元素为 [B, C]，这些元素在旧列表中可以保留原位置。

   E 是新元素，需要插入，A需要从位置0移动到最后



最长递增子序列函数实现，详细讲解在src/core/vdom/vue3getSequency.js

```js
function getSequence(arr) {
  const p = arr.slice();
  const result = [0];
  let i, j, u, v, c;
  const len = arr.length;
  for (i = 0; i < len; i++) {
    const arrI = arr[i];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p[i] = j;
        result.push(i);
        continue;
      }
      u = 0;
      v = result.length - 1;
      while (u < v) {
        c = (u + v) >> 1;
        if (arr[result[c]] < arrI) {
          u = c + 1;
        } else {
          v = c;
        }
      }
      if (arrI < arr[result[u]]) {
        if (u > 0) {
          p[i] = result[u - 1];
        }
        result[u] = i;
      }
    }
  }
  u = result.length;
  v = result[u - 1];
  while (u-- > 0) {
    result[u] = v;
    v = p[v];
  }
  return result;
}
```

































