## 实现 vue2 的主要功能

- new Vue 发生了什么
- 模板编译
- 响应式系统
- 事件处理
- 插槽





## vue2 diff 算法

### 1. 流程

详情见代码 src/vdom/patch，对比核心代码发生在updateChildren





### 2.缺点

>  vue2 diff 算法对比的过程中，在经历完 头头、头尾、尾尾、尾头后，会根据旧节点做一个映射表，键为 key（v-for 提供的key），值为 索引。在旧节点中找到能复用的节点，从而移动旧节点。



1. 静态节点不缓存

   在vue2中，每次渲染都会重新生成虚拟DOM 树，即使是静态节点也会重新生成和比较，这导致了不必要的开销，尤其是在包含大量静态内容的应用中

   

2. 更新时全量比较

   vue2 的 diff 算法会对整个虚拟 DOM 树进行全量比较，虽然已经尽量优化了性能，但在某些复杂的场景下，仍然会导致性能问题。例如，嵌套层级较深的组件树或者包含大量子节点的组件更新时，可能会出现性能瓶颈。

> vue2的diff算法在对于大列表的数据更新效率不高，因为它需要对整个列表进行diff，即使只有少数几个元素发生变化。这是因为vue2的diff算法是基于索引的，它依赖于可以通过索引直接获取到相应的vnode，然后进行比较。但当列表较大时，索引的查找成本较高，这使得算法的时间复杂度随着列表的大小而线性增加
>
> 使用key之后，Vue可以更快地确定哪些元素可以复用。

```js
//这里是在创建旧节点的映射表 
oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);

//有key 通过key来找到索引，没有key则会遍历旧节点列表来找到对应的索引
//没有key的情况下，当列表较大时，索引查找成本较高
idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
```



3. 列表更新的效率问题

   在处理列表更新时，vue2 的 diff 算法通过 key 属性来优化节点的复用和移动。但是当key不正确或者未设置时，栓发的性能会大幅下降，导致不必要的DOM 操作。即使设置了key，在列表元素频繁增删的情况下，diff 算法的性能仍然不够理想。

> 长列表：
>
> ​	在非常长的列表中，即使使用 `key` 来优化节点的复用和移动，diff 算法仍然需要遍历整个列表，计算复杂度为 O(n)，在极端情况下（如同时进行大量插入、删除和移动操作），性能开销仍然较大。
>
> 频繁插入和删除操作：
>
> ​	如果列表频繁变动，特别是在头部或者中间插入、删除操作时，vue需要重新计算每个项的位置，如下面的例子。

```html
头部插入：
<ul>
  <li key="1">Item 1</li>
  <li key="2">Item 2</li>
  <li key="3">Item 3</li>
</ul>

<ul>
  <li key="4">Item 4</li>
  <li key="1">Item 1</li>
  <li key="2">Item 2</li>
  <li key="3">Item 3</li>
</ul>
```

1. 比较节点：

   1. Vue 将新的 `key="4"` 与旧的 `key="1"` 进行比较，发现它们不相同。
   2. Vue 需要插入一个新的节点并**重新调整后面的所有节点**。

2. 移动节点：

   1. 旧的 `key="1"` 需要移到新位置。
   2. 旧的 `key="2"` 需要移到新位置。
   3. 旧的 `key="3"` 需要移到新位置。

   ​	

```html
中间插入：
<ul>
  <li key="1">Item 1</li>
  <li key="5">Item 5</li>
  <li key="2">Item 2</li>
  <li key="3">Item 3</li>
</ul>
```

1. 比较节点：
   1. Vue 将新的 `key="1"` 与旧的 `key="1"` 进行比较，发现它们相同，继续比较下一个节点。
   2. Vue 将新的 `key="5"` 与旧的 `key="2"` 进行比较，发现它们不相同。
2. 插入新节点：
   1. Vue 需要插入新的 `key="5"` 节点。
3. 移动节点：
   1. 旧的 `key="2"` 和 `key="3"` 需要移到新位置。



所以在vue2的diff 算法过程中，在头部或中间插入或删除节点时，所有后续节点的位置都需要重新计算和更新。这种重新计算会导致多个 DOM 操作。每一次 DOM 操作都会触发浏览器的重新布局（reflow）和重绘（repaint），这些操作都是相对昂贵的。



> ​	在vue2 的diff 算法中，它会把新节点在旧节点中寻找，如果可以复用，那么就会产生移动。vue2的diff 算法没有去关注哪些节点不用去移动，这样就会产生额外的移动操作
>
> vue3中采用了最长递增子序列的思想，尽量减少移动节点，减少无意义的移动
>
> 例子：
>
> a b c d
>
> e b c d a h
>
> 对于 e 节点进行双端对比，发现匹配不到，会创建 e节点添加到头部，然后指针移动到b节点，继续双端对比，发现还是匹配不到，拿b节点去旧节点中找相同的b节点（通过key可以快速找到），然后将b节点移动到前面，指针继续后移动到c节点...
>
> 对于旧列表 bcd 节点，新列表中也是 bcd ，完全可以不用移动，只需要将 a节点移动到 d后面就可以



4. Vue 2 使用数据劫持（Object.defineProperty）实现双向数据绑定，虽然这在大多数情况下表现良好，但在处理大量数据或者频繁更新的场景下，仍然会有一定的性能开销。







































